/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */
package cw20base

import (
	"context"
	"encoding/json"
	wasmtypes "github.com/CosmWasm/wasmd/x/wasm/types"
	grpc "google.golang.org/grpc"
	insecure "google.golang.org/grpc/credentials/insecure"
)

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// AllSpenderAllowances is the client API for the QueryMsg_AllSpenderAllowances query message
	AllSpenderAllowances(ctx context.Context, req *QueryMsg_AllSpenderAllowances, opts ...grpc.CallOption) (*AllSpenderAllowancesResponse, error)
	// DownloadLogo is the client API for the QueryMsg_DownloadLogo query message
	DownloadLogo(ctx context.Context, req *QueryMsg_DownloadLogo, opts ...grpc.CallOption) (*DownloadLogoResponse, error)
	// TokenInfo is the client API for the QueryMsg_TokenInfo query message
	TokenInfo(ctx context.Context, req *QueryMsg_TokenInfo, opts ...grpc.CallOption) (*TokenInfoResponse, error)
	// AllAccounts is the client API for the QueryMsg_AllAccounts query message
	AllAccounts(ctx context.Context, req *QueryMsg_AllAccounts, opts ...grpc.CallOption) (*AllAccountsResponse, error)
	// AllAllowances is the client API for the QueryMsg_AllAllowances query message
	AllAllowances(ctx context.Context, req *QueryMsg_AllAllowances, opts ...grpc.CallOption) (*AllAllowancesResponse, error)
	// MarketingInfo is the client API for the QueryMsg_MarketingInfo query message
	MarketingInfo(ctx context.Context, req *QueryMsg_MarketingInfo, opts ...grpc.CallOption) (*MarketingInfoResponse, error)
	// Minter is the client API for the QueryMsg_Minter query message
	Minter(ctx context.Context, req *QueryMsg_Minter, opts ...grpc.CallOption) (*MinterResponse_2, error)
	// Allowance is the client API for the QueryMsg_Allowance query message
	Allowance(ctx context.Context, req *QueryMsg_Allowance, opts ...grpc.CallOption) (*AllowanceResponse, error)
	// Balance is the client API for the QueryMsg_Balance query message
	Balance(ctx context.Context, req *QueryMsg_Balance, opts ...grpc.CallOption) (*BalanceResponse, error)
}

type queryClient struct {
	cc      *grpc.ClientConn
	address string
}

var _ QueryClient = (*queryClient)(nil)

// NewQueryClient creates a new QueryClient
func NewQueryClient(gRPCAddress, contractAddress string, opts ...grpc.DialOption) (QueryClient, error) {
	if len(opts) == 0 {
		opts = append(opts, grpc.WithTransportCredentials(insecure.NewCredentials()))
	}

	// Create a connection to the gRPC server
	grpcConn, err := grpc.Dial(gRPCAddress, opts...)
	if err != nil {
		return nil, err
	}

	return &queryClient{
		address: contractAddress,
		cc:      grpcConn,
	}, nil
}

// Close closes the gRPC connection to the server
func (q *queryClient) Close() error {
	return q.cc.Close()
}

// queryContract is a helper function to query the contract with raw query data
func (q *queryClient) queryContract(ctx context.Context, rawQueryData []byte, opts ...grpc.CallOption) ([]byte, error) {
	in := &wasmtypes.QuerySmartContractStateRequest{
		Address:   q.address,
		QueryData: rawQueryData,
	}
	out := new(wasmtypes.QuerySmartContractStateResponse)
	err := q.cc.Invoke(ctx, "/cosmwasm.wasm.v1.Query/SmartContractState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out.Data, nil
}

func (q *queryClient) AllAccounts(ctx context.Context, req *QueryMsg_AllAccounts, opts ...grpc.CallOption) (*AllAccountsResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{AllAccounts: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response AllAccountsResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) AllAllowances(ctx context.Context, req *QueryMsg_AllAllowances, opts ...grpc.CallOption) (*AllAllowancesResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{AllAllowances: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response AllAllowancesResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) AllSpenderAllowances(ctx context.Context, req *QueryMsg_AllSpenderAllowances, opts ...grpc.CallOption) (*AllSpenderAllowancesResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{AllSpenderAllowances: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response AllSpenderAllowancesResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) DownloadLogo(ctx context.Context, req *QueryMsg_DownloadLogo, opts ...grpc.CallOption) (*DownloadLogoResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{DownloadLogo: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response DownloadLogoResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) TokenInfo(ctx context.Context, req *QueryMsg_TokenInfo, opts ...grpc.CallOption) (*TokenInfoResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{TokenInfo: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response TokenInfoResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) Allowance(ctx context.Context, req *QueryMsg_Allowance, opts ...grpc.CallOption) (*AllowanceResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{Allowance: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response AllowanceResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) Balance(ctx context.Context, req *QueryMsg_Balance, opts ...grpc.CallOption) (*BalanceResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{Balance: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response BalanceResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) MarketingInfo(ctx context.Context, req *QueryMsg_MarketingInfo, opts ...grpc.CallOption) (*MarketingInfoResponse, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{MarketingInfo: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response MarketingInfoResponse
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}

func (q *queryClient) Minter(ctx context.Context, req *QueryMsg_Minter, opts ...grpc.CallOption) (*MinterResponse_2, error) {
	rawQueryData, err := json.Marshal(&QueryMsg{Minter: req})
	if err != nil {
		return nil, err
	}

	rawResponseData, err := q.queryContract(ctx, rawQueryData, opts...)
	if err != nil {
		return nil, err
	}

	var response MinterResponse_2
	if err := json.Unmarshal(rawResponseData, &response); err != nil {
		return nil, err
	}

	return &response, nil
}
