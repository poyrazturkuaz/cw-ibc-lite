/* Code generated by github.com/srdtrk/go-codegen, DO NOT EDIT. */
package ics26router

// The message to instantiate the contract.
type InstantiateMsg struct {
	// cw-ibc-lite-ics02-client router code id
	Ics02ClientCodeId int `json:"ics02_client_code_id"`
	// The owner of the contract. This address can register IBC apps with custom port IDs. Use CosmosSDK governance module address if unsure.
	Owner string `json:"owner"`
}

// The execute messages supported by the contract.
type ExecuteMsg struct {
	// Send a packet to another client.
	SendPacket *ExecuteMsg_SendPacket `json:"send_packet,omitempty"`
	// Receive a packet from another client. From https://github.com/cosmos/ibc-go/blob/cf191f4ab3ff27a2e68b3dac17c547669f80102c/modules/core/04-channel/types/tx.pb.go#L646
	RecvPacket *ExecuteMsg_RecvPacket `json:"recv_packet,omitempty"`
	// Acknowledge a packet sent to another client. From https://github.com/cosmos/ibc-go/blob/cf191f4ab3ff27a2e68b3dac17c547669f80102c/modules/core/04-channel/types/tx.pb.go#L887
	Acknowledgement *ExecuteMsg_Acknowledgement `json:"acknowledgement,omitempty"`
	// Timeout a packet sent to another client. From https://github.com/cosmos/ibc-go/blob/cf191f4ab3ff27a2e68b3dac17c547669f80102c/modules/core/04-channel/types/tx.pb.go#L725
	Timeout *ExecuteMsg_Timeout `json:"timeout,omitempty"`
	// Anyone can register an IBC app with this contract. A custom port ID can only be provided if the caller is the admin of the contract.
	RegisterIbcApp *ExecuteMsg_RegisterIbcApp `json:"register_ibc_app,omitempty"`
}

// The query messages supported by the contract.
type QueryMsg struct {
	// PortRouter queries the contract address of the IBC app registered with the given port ID.
	PortRouter *QueryMsg_PortRouter `json:"port_router,omitempty"`
}

// The message to acknowledge a packet sent to another client.
type AcknowledgementMsg struct {
	// The acknowledgement data.
	Acknowledgement Binary `json:"acknowledgement"`
	// The packet to acknowledge.
	Packet Packet `json:"packet"`
	// The proof of the acknowledgement.
	ProofAcked Binary `json:"proof_acked"`
	// The height of the proof.
	ProofHeight Height `json:"proof_height"`
}

// The sequence number of a packet enforces ordering among packets from the same source.
type Sequence int

type QueryMsg_PortRouter struct {
	// The port ID of the router.
	PortId string `json:"port_id"`
}
type ExecuteMsg_SendPacket SendPacketMsg
type ExecuteMsg_Timeout TimeoutMsg

// The message to timeout a packet sent to another client.
type TimeoutMsg struct {
	// The height of the proof.
	ProofHeight Height `json:"proof_height"`
	// The proof that the packet is unreceived.
	ProofUnreceived Binary `json:"proof_unreceived"`
	// The next sequence receive number.
	NextSequenceRecv int `json:"next_sequence_recv"`
	// The packet to timeout.
	Packet Packet `json:"packet"`
}

/*
A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.

# Examples

Use `from` to create instances of this and `u64` to get the value out:

``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);

let b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```
*/
type Uint64 string

type ClientId string

// In IBC each package must set at least one type of timeout: the timestamp or the block height. Using this rather complex enum instead of two timeout fields we ensure that at least one timeout is set.
type IbcTimeout struct {
	Block     *IbcTimeoutBlock `json:"block,omitempty"`
	Timestamp *Timestamp       `json:"timestamp,omitempty"`
}
type ExecuteMsg_RecvPacket RecvPacketMsg
type ExecuteMsg_Acknowledgement AcknowledgementMsg

type ExecuteMsg_RegisterIbcApp struct {
	// The contract address of the IBC app.
	Address string `json:"address"`
	// The port ID of the IBC app. Can only be provided by the admin of the contract. If not provided, the contract address is used with the [`super::keys::PORT_ID_PREFIX`] prefix.
	PortId *string `json:"port_id,omitempty"`
}

/*
Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.

This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
*/
type Binary string

/*
Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients

Normally the `RevisionHeight` is incremented at each height while keeping `RevisionNumber` the same. However some consensus algorithms may choose to reset the height in certain conditions e.g. hard forks, state-machine breaking changes In these cases, the `RevisionNumber` is incremented so that height continues to be monitonically increasing even as the `RevisionHeight` gets reset
*/
type Height struct {
	// the height within the given revision
	RevisionHeight int `json:"revision_height"`
	// the revision that the client is currently on
	RevisionNumber int `json:"revision_number"`
}

// IBCTimeoutHeight Height is a monotonically increasing data type that can be compared against another Height for the purposes of updating and freezing clients. Ordering is (revision_number, timeout_height)
type IbcTimeoutBlock struct {
	// block height after which the packet times out. the height within the given revision
	Height int `json:"height"`
	// the version that the client is currently on (e.g. after resetting the chain this could increment 1 as height drops to 0)
	Revision int `json:"revision"`
}

// The message to send a packet to another client.
type SendPacketMsg struct {
	// The destination port ID.
	DestPort string `json:"dest_port"`
	// The source client ID.
	SourceChannel string `json:"source_channel"`
	// The source port ID.
	SourcePort string `json:"source_port"`
	// Timeout information for the packet.
	Timeout IbcTimeout `json:"timeout"`
	// The application version.
	Version string `json:"version"`
	// The packet data to commit.
	Data Binary `json:"data"`
	// The destination client ID.
	DestChannel *string `json:"dest_channel,omitempty"`
}

// The message to receive a packet from another client.
type RecvPacketMsg struct {
	// The packet to receive.
	Packet Packet `json:"packet"`
	// The proof of the packet commitment.
	ProofCommitment Binary `json:"proof_commitment"`
	// The height of the proof.
	ProofHeight Height `json:"proof_height"`
}

/*
A point in time in nanosecond precision.

This type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.

## Examples

``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);

let ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```
*/
type Timestamp Uint64

// Packet defines a type that carries data across different chains through IBC
type Packet struct {
	// identifies the port on the sending chain.
	SourcePort PortId `json:"source_port"`
	// block height after which the packet times out
	Timeout IbcTimeout `json:"timeout"`
	// actual opaque bytes transferred directly to the application module
	Data Binary `json:"data"`
	// identifies the channel end on the receiving chain.
	DestinationChannel ClientId `json:"destination_channel"`
	// identifies the port on the receiving chain.
	DestinationPort PortId `json:"destination_port"`
	// number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.
	Sequence Sequence `json:"sequence"`
	// identifies the channel end on the sending chain.
	SourceChannel ClientId `json:"source_channel"`
}

type PortId string
